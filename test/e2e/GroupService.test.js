/* eslint-env mocha */
/* eslint-disable no-unused-expressions */

const _ = require('lodash')
const chai = require('chai')
const chaiHttp = require('chai-http')
const should = chai.should() // eslint-disable-line
const sinonChai = require('sinon-chai')
const chaiAsPromised = require('chai-as-promised')

const groups = require('../common/data/groups.json')
const members = require('../common/data/members.json')
const tokens = require('../common/data/tokens.json')
const helper = require('../common/helper')

const app = require('../../app')
const constants = require('../../app-constants')
const errors = require('../../src/common/errors')

chai.use(chaiHttp)
chai.use(sinonChai)
chai.use(chaiAsPromised)

const autoGeneratedGroupAttrs = ['createdBy', 'createdAt', 'id']
const updateAttrs = ['updatedBy', 'updatedAt', 'oldName']
const validateGroupResponse = (res, group, options = {}) => {
  const { isCreate, isUpdate, isStatusHidden } = options

  let keys = Object.keys(group)
  if (isCreate || isUpdate) {
    keys = _.concat(keys, autoGeneratedGroupAttrs)
    if (isUpdate) {
      keys = _.concat(keys, updateAttrs)
    }
    res.body.id.should.not.be.eql(null)
  } else {
    res.body.id.should.be.eql(group.id)
  }

  res.body.should.have.all.keys(keys)
  res.body.name.should.be.eql(group.name)
  res.body.description.should.be.eql(group.description)
  res.body.privateGroup.should.be.eql(group.privateGroup)
  res.body.selfRegister.should.be.eql(group.selfRegister)
  res.body.domain.should.be.eql(group.domain)
  res.body.ssoId.should.be.eql(group.ssoId)

  if (!isStatusHidden) {
    res.body.status.should.be.eql(group.status)
  }
}

describe('Group Service Tests', () => {
  beforeEach(async function () {
    await helper.createGroups(Object.values(groups.PRE_CREATED))
    const users = _.uniq(members.PRE_CREATED.User.map(membership => membership.memberId))
    await helper.createUsers(users)
    await Promise.all(
      Object.entries(members.PRE_CREATED)
        .map(pair => helper.addMembersToGroup(pair[1], pair[0]))
    )
  })
  afterEach(async function () {
    await helper.clearDB()
  })

  describe('POST /groups', () => {
    describe('creating a group', () => {
      it('without name should return 400', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(groups.VALID, 'name'))
        res.should.have.status(400)
        res.body.message.should.eql('"name" is required')
      })
      it('without privateGroup flag should return 400', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(groups.VALID, 'privateGroup'))
        res.should.have.status(400)
        res.body.message.should.eql('"privateGroup" is required')
      })
      it('without selfRegister flag should return 400', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(groups.VALID, 'selfRegister'))
        res.should.have.status(400)
        res.body.message.should.eql('"selfRegister" is required')
      })
      it('with existing name should return 409', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(groups.PRE_CREATED.PUBLIC, autoGeneratedGroupAttrs, 'oldId'))
        res.should.have.status(409)
      })
      it('with non-admin user token should return 403', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.User.User}`)
          .send(groups.VALID)
        res.should.have.status(403)

        const allGroups = await helper.getAllGroups()
        const names = allGroups.map(g => g.name)
        names.should.not.include(groups.VALID.name)
      })
      it('without token should return 403', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .send(groups.VALID)
        res.should.have.status(403)

        const allGroups = await helper.getAllGroups()
        const names = allGroups.map(g => g.name)
        names.should.not.include(groups.VALID.name)
      })
      it('with admin token should be successful', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(groups.VALID)

        res.should.have.status(200)
        validateGroupResponse(res, groups.VALID, { isCreate: true })
        helper.stubbedBus.should.have.been.called

        const dbEntity = await helper.getGroup(res.body.id)
        dbEntity.should.be.deep.eql(res.body)
      })
      it('with M2M read-only token should return 403', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.M2M.R}`)
          .send(groups.VALID)

        res.should.have.status(403)

        const allGroups = await helper.getAllGroups()
        const names = allGroups.map(g => g.name)
        names.should.not.include(groups.VALID.name)
      })
      it('with M2M write-only token should be successful', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.M2M.W}`)
          .send(groups.VALID)

        res.should.have.status(200)
        validateGroupResponse(res, groups.VALID, { isCreate: true })
        helper.stubbedBus.should.have.been.called

        const dbEntity = await helper.getGroup(res.body.id)
        dbEntity.should.be.deep.eql(res.body)
      })
      it('with M2M read-write token should be successful', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.M2M.RW}`)
          .send(groups.VALID)

        res.should.have.status(200)
        validateGroupResponse(res, groups.VALID, { isCreate: true })
        helper.stubbedBus.should.have.been.called

        const dbEntity = await helper.getGroup(res.body.id)
        dbEntity.should.be.deep.eql(res.body)
      })
      it('with M2M all:groups token should be successful', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.M2M.ALL}`)
          .send(groups.VALID)

        res.should.have.status(200)
        validateGroupResponse(res, groups.VALID, { isCreate: true })
        helper.stubbedBus.should.have.been.called

        const dbEntity = await helper.getGroup(res.body.id)
        dbEntity.should.be.deep.eql(res.body)
      })
      it('without status should set default status', async () => {
        const res = await chai.request(app)
          .post('/groups')
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(groups.VALID, 'status'))

        res.should.have.status(200)
        validateGroupResponse(
          res,
          { ...groups.VALID, status: constants.GroupStatus.Active },
          { isCreate: true }
        )
        helper.stubbedBus.should.have.been.called

        const dbEntity = await helper.getGroup(res.body.id)
        dbEntity.should.be.deep.eql(res.body)
      })
    })
  })

  describe('GET /groups/:groupId', () => {
    describe('fetching a group', () => {
      it('without token should return 403', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}`)
        res.should.have.status(403)
      })
      it('by specifying both includeSubGroups & includeParentGroup should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}?includeSubGroups=true&includeParentGroup=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(400)
      })
      it('that is public with user token should be successful with status hidden', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.User}`)

        res.should.have.status(200)
        validateGroupResponse(res, _.omit(group, 'status'), { isStatusHidden: true })

        const dbEntity = await helper.getGroup(group.id)
        _.omit(dbEntity, 'status').should.be.deep.eql(res.body)
      })
      it('that is public with admin token should be successful with status shown', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        validateGroupResponse(res, group)

        const dbEntity = await helper.getGroup(group.id)
        dbEntity.should.be.deep.eql(res.body)
      })
      it('that is public with M2M token should be successful with status hidden', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.M2M.R}`)

        res.should.have.status(200)
        validateGroupResponse(res, _.omit(group, 'status'), { isStatusHidden: true })

        const dbEntity = await helper.getGroup(group.id)
        _.omit(dbEntity, 'status').should.be.deep.eql(res.body)
      })
      it('that is private with user token should return 403', async () => {
        const group = groups.PRE_CREATED.PRIVATE
        const res = await chai.request(app)
          .get(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.User}`)

        res.should.have.status(403)
      })
      it('that is private with M2M token should be successful with status hidden', async () => {
        const group = groups.PRE_CREATED.PRIVATE
        const res = await chai.request(app)
          .get(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.M2M.R}`)

        res.should.have.status(200)
        validateGroupResponse(res, _.omit(group, 'status'), { isStatusHidden: true })

        const dbEntity = await helper.getGroup(group.id)
        _.omit(dbEntity, 'status').should.be.deep.eql(res.body)
      })
      it('that is private with admin token should be successful with status shown', async () => {
        const group = groups.PRE_CREATED.PRIVATE
        const res = await chai.request(app)
          .get(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        validateGroupResponse(res, group)

        const dbEntity = await helper.getGroup(group.id)
        dbEntity.should.be.deep.eql(res.body)
      })
      it('with fields should only return specifed fields in response', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}?fields=description,domain`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        res.body.should.have.all.keys(['domain', 'description'])
        res.body.description.should.be.eql(group.description)
        res.body.domain.should.be.eql(group.domain)
      })
      it('with disallowed fields should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}?fields=description,domain,status`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(400)
      })
      it('with duplicate fields should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}?fields=description,domain,domain`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(400)
      })
      it('with includeSubGroups set should include child groups as well', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/${group.id}?includeSubGroups=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        _.omit(res.body.subGroups[0], 'subGroups').should.deep.include(groups.PRE_CREATED.PUBLIC_CHILD)
      })
      it('with includeParentGroup set should include parent group as well', async () => {
        const group = groups.PRE_CREATED.PUBLIC_CHILD
        const res = await chai.request(app)
          .get(`/groups/${group.id}?includeParentGroup=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        res.body.parentGroups.should.deep.include(groups.PRE_CREATED.PUBLIC)
      })
      it('with includeParentGroup with oneLevel set to true should not include grandParent groups', async () => {
        const group = groups.PRE_CREATED.PUBLIC_GRANDCHILD
        const res = await chai.request(app)
          .get(`/groups/${group.id}?includeParentGroup=true&oneLevel=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        res.body.parentGroups[0].should.not.have.own.property('parentGroups')
      })
      it('with includeParentGroup with oneLevel set to false should include grandParent groups', async () => {
        const group = groups.PRE_CREATED.PUBLIC_GRANDCHILD
        const res = await chai.request(app)
          .get(`/groups/${group.id}?includeParentGroup=true&oneLevel=false`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        _.omit(res.body.parentGroups[0], 'parentGroups').should.be.eql(groups.PRE_CREATED.PUBLIC_CHILD)
        res.body.parentGroups[0].should.have.own.property('parentGroups')
        _.omit(res.body.parentGroups[0].parentGroups[0], 'parentGroups').should.eql(groups.PRE_CREATED.PUBLIC)
      })
    })
  })

  describe('PUT /groups/:groupId', () => {
    describe('updating a group', () => {
      it('without name should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(group, 'name'))
        res.should.have.status(400)
        res.body.message.should.eql('"name" is required')
      })
      it('without privateGroup flag should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(group, 'privateGroup'))
        res.should.have.status(400)
        res.body.message.should.eql('"privateGroup" is required')
      })
      it('without selfRegister flag should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(group, 'selfRegister'))
        res.should.have.status(400)
        res.body.message.should.eql('"selfRegister" is required')
      })
      it('with user token should return 403', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const updatedGroup = _.omit({ ...group, domain: 'abcd.com' }, autoGeneratedGroupAttrs)
        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.User}`)
          .send(updatedGroup)
        res.should.have.status(403)

        const entity = await helper.getGroup(group.id)
        entity.domain.should.be.eql(group.domain)
      })
      it('without a token should return 403', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const updatedGroup = _.omit({ ...group, domain: 'abcd.com' }, autoGeneratedGroupAttrs)
        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .send(updatedGroup)
        res.should.have.status(403)

        const entity = await helper.getGroup(group.id)
        entity.domain.should.be.eql(group.domain)
      })
      it('that does not exist should return 404', async () => {
        const groupId = groups.NON_EXISTENT_ID
        const updatedGroup = _.omit({ ...groups.PRE_CREATED.PUBLIC, domain: 'abcd.com' }, autoGeneratedGroupAttrs, 'oldId')
        const res = await chai.request(app)
          .put(`/groups/${groupId}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(updatedGroup)
        res.should.have.status(404)
      })
      it('with admin token should be successful', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const updatedGroup = _.omit({ ...group, domain: 'abcd.com' }, autoGeneratedGroupAttrs)
        const existingEntity = await helper.getGroup(group.id)

        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(_.omit(updatedGroup, 'oldId'))
        res.should.have.status(200)
        validateGroupResponse(res, updatedGroup, { isUpdate: true })

        const updatedEntity = await helper.getGroup(group.id)
        updatedEntity.should.have.own.property('updatedBy')
        updatedEntity.should.have.own.property('updatedAt')

        _.omit(updatedEntity, 'updatedAt', 'updatedBy').should.be.deep.eql({
          ...existingEntity,
          domain: 'abcd.com'
        })
      })
      it('with M2M read-only token should return 403', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const updatedGroup = _.omit({ ...group, domain: 'abcd.com' }, autoGeneratedGroupAttrs)
        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.M2M.R}`)
          .send(_.omit(updatedGroup, 'oldId'))
        res.should.have.status(403)

        const entity = await helper.getGroup(group.id)
        entity.domain.should.be.eql(group.domain)
      })
      it('with M2M write-only token should be successful', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const updatedGroup = _.omit({ ...group, domain: 'abcd.com' }, autoGeneratedGroupAttrs)
        const existingEntity = await helper.getGroup(group.id)

        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.M2M.W}`)
          .send(_.omit(updatedGroup, 'oldId'))
        res.should.have.status(200)
        validateGroupResponse(res, updatedGroup, { isUpdate: true })

        const updatedEntity = await helper.getGroup(group.id)
        updatedEntity.should.have.own.property('updatedBy')
        updatedEntity.should.have.own.property('updatedAt')

        _.omit(updatedEntity, 'updatedAt', 'updatedBy').should.be.deep.eql({
          ...existingEntity,
          domain: 'abcd.com'
        })
      })
      it('with M2M all:groups token should be successful', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const updatedGroup = _.omit({ ...group, domain: 'abcd.com' }, autoGeneratedGroupAttrs)
        const existingEntity = await helper.getGroup(group.id)

        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.M2M.ALL}`)
          .send(_.omit(updatedGroup, 'oldId'))
        res.should.have.status(200)
        validateGroupResponse(res, updatedGroup, { isUpdate: true })

        const updatedEntity = await helper.getGroup(group.id)
        updatedEntity.should.have.own.property('updatedBy')
        updatedEntity.should.have.own.property('updatedAt')

        _.omit(updatedEntity, 'updatedAt', 'updatedBy').should.be.deep.eql({
          ...existingEntity,
          domain: 'abcd.com'
        })
      })
      it('without specifying "status" in the payload should not set it to any default value', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const updatedGroup = _.omit({ ...group, domain: 'abcd.com' }, autoGeneratedGroupAttrs.concat(['status', 'oldId']))
        const res = await chai.request(app)
          .put(`/groups/${group.id}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
          .send(updatedGroup)
        res.should.have.status(200)
        res.body.should.not.have.key('status')
      })
    })
  })

  describe('DELETE /groups/:groupId', () => {
    describe('deleting a group', () => {
      it('that does not exist should return 404', async () => {
        const res = await chai.request(app)
          .delete(`/groups/${groups.NON_EXISTENT_ID}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(404)
      })
      it('with non-admin user token should return 403', async () => {
        const res = await chai.request(app)
          .delete(`/groups/${groups.PRE_CREATED.PUBLIC.id}`)
          .set('Authorization', `Bearer ${tokens.User.User}`)
        res.should.have.status(403)
        helper.getGroup(groups.PRE_CREATED.PUBLIC.id).should.not.be.rejected
      })
      it('with M2M read-only token should return 403', async () => {
        const res = await chai.request(app)
          .delete(`/groups/${groups.PRE_CREATED.PUBLIC.id}`)
          .set('Authorization', `Bearer ${tokens.M2M.R}`)
        res.should.have.status(403)
        helper.getGroup(groups.PRE_CREATED.PUBLIC.id).should.not.be.rejected
      })
      it('with admin user token should be successful', async () => {
        await helper.getGroup(groups.PRE_CREATED.PUBLIC.id)
        const res = await chai.request(app)
          .delete(`/groups/${groups.PRE_CREATED.PUBLIC.id}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(200)
        validateGroupResponse(res, groups.PRE_CREATED.PUBLIC)

        helper.getGroup(groups.PRE_CREATED.PUBLIC.id)
          .should.be.rejectedWith(errors.NotFoundError)
      })
      it('with M2M write token should be successful', async () => {
        await helper.getGroup(groups.PRE_CREATED.PUBLIC.id)
        const res = await chai.request(app)
          .delete(`/groups/${groups.PRE_CREATED.PUBLIC.id}`)
          .set('Authorization', `Bearer ${tokens.M2M.W}`)
        res.should.have.status(200)
        validateGroupResponse(res, groups.PRE_CREATED.PUBLIC)

        helper.getGroup(groups.PRE_CREATED.PUBLIC.id)
          .should.be.rejectedWith(errors.NotFoundError)
      })
      it('with M2M all:groups token should be successful', async () => {
        await helper.getGroup(groups.PRE_CREATED.PUBLIC.id)
        const res = await chai.request(app)
          .delete(`/groups/${groups.PRE_CREATED.PUBLIC.id}`)
          .set('Authorization', `Bearer ${tokens.M2M.ALL}`)
        res.should.have.status(200)
        validateGroupResponse(res, groups.PRE_CREATED.PUBLIC)

        helper.getGroup(groups.PRE_CREATED.PUBLIC.id)
          .should.be.rejectedWith(errors.NotFoundError)
      })
    })
  })

  describe('GET /groups', () => {
    describe('fetching groups', () => {
      it('with admin token should be successful', async () => {
        const res = await chai.request(app)
          .get('/groups')
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(200)
        res.body.should.have.length(7)
      })
      it('with M2M token should be successful', async () => {
        const res = await chai.request(app)
          .get('/groups')
          .set('Authorization', `Bearer ${tokens.M2M.R}`)
        res.should.have.status(200)
        res.body.should.have.length(7)
      })
      it('with non-admin user token should only fetch groups that the user is part of', async () => {
        const res = await chai.request(app)
          .get('/groups')
          .set('Authorization', `Bearer ${tokens.User.User}`)
        res.should.have.status(200)
        res.body.should.have.length(3)

        const groupNames = res.body.map(g => g.name)
        groupNames.should.include(groups.PRE_CREATED.PUBLIC.name)
        groupNames.should.include(groups.PRE_CREATED.SELF_REGISTER.name)
      })
      it('with non-admin user token should not include group status', async () => {
        const res = await chai.request(app)
          .get('/groups')
          .set('Authorization', `Bearer ${tokens.User.User}`)
        res.should.have.status(200)
        res.body.should.have.length(3)
        res.body[0].should.not.contain.key('status')
      })
      it('with criteria should be successful', async () => {
        const { name, privateGroup, selfRegister, ssoId, oldId } = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups?name=${name}&privateGroup=${privateGroup}&selfRegister=${selfRegister}&ssoId=${ssoId}&oldId=${oldId}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(200)

        res.body[0].name.should.be.eql(name)
        res.body[0].privateGroup.should.be.eql(privateGroup)
        res.body[0].selfRegister.should.be.eql(selfRegister)
        res.body[0].ssoId.should.be.eql(ssoId)
        res.body[0].oldId.should.be.eql(oldId)
      })
      it('with includeSubGroups should be include subgroups', async () => {
        const { name } = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups?name=${name}&includeSubGroups=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(200)

        res.body[0].subGroups[0].should.be.eql(groups.PRE_CREATED.PUBLIC_CHILD)
      })
      it('with includeParentGroup should be include parent group', async () => {
        const { name } = groups.PRE_CREATED.PUBLIC_CHILD
        const res = await chai.request(app)
          .get(`/groups?name=${name}&includeParentGroup=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(200)

        res.body[0].parentGroups[0].should.be.eql(groups.PRE_CREATED.PUBLIC)
      })
      it('with memberId criteria without membershipType should return 400', async () => {
        const { memberId } = members.PRE_CREATED.User[0]
        const res = await chai.request(app)
          .get(`/groups?memberId=${memberId}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(400)
      })
      it('with membershipType criteria without memberId should return 400', async () => {
        const { membershipType } = members.PRE_CREATED.User[0]
        const res = await chai.request(app)
          .get(`/groups?membershipType=${membershipType}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(400)
      })
    })
  })

  describe('GET /groups/oldId/:oldId', () => {
    describe('using oldId to fetch a group', () => {
      it('without token should return 403', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}`)
        res.should.have.status(403)
      })
      it('by specifying both includeSubGroups & includeParentGroup should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}?includeSubGroups=true&includeParentGroup=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)
        res.should.have.status(400)
      })
      it('that is public with user token should be successful with status hidden', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}`)
          .set('Authorization', `Bearer ${tokens.User.User}`)

        res.should.have.status(200)
        validateGroupResponse(res, _.omit(group, 'status'), { isStatusHidden: true })
      })
      it('that is public with admin token should be successful with status shown', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        validateGroupResponse(res, group)
      })
      it('that is public with M2M token should be successful with status hidden', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}`)
          .set('Authorization', `Bearer ${tokens.M2M.R}`)

        res.should.have.status(200)
        validateGroupResponse(res, _.omit(group, 'status'), { isStatusHidden: true })
      })
      it('that is private with user token should return 403', async () => {
        const group = groups.PRE_CREATED.PRIVATE
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}`)
          .set('Authorization', `Bearer ${tokens.User.User}`)

        res.should.have.status(403)
      })
      it('that is private with M2M token should be successful with status hidden', async () => {
        const group = groups.PRE_CREATED.PRIVATE
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}`)
          .set('Authorization', `Bearer ${tokens.M2M.R}`)

        res.should.have.status(200)
        validateGroupResponse(res, _.omit(group, 'status'), { isStatusHidden: true })
      })
      it('that is private with admin token should be successful with status shown', async () => {
        const group = groups.PRE_CREATED.PRIVATE
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        validateGroupResponse(res, group)
      })
      it('with fields should only return specifed fields in response', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}?fields=description,domain`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
        res.body.should.have.all.keys(['domain', 'description'])
        res.body.description.should.be.eql(group.description)
        res.body.domain.should.be.eql(group.domain)
      })
      it('with disallowed fields should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}?fields=description,domain,status`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(400)
      })
      it('with duplicate fields should return 400', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}?fields=description,domain,domain`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(400)
      })
      it('with includeSubGroups set should include child groups as well', async () => {
        const group = groups.PRE_CREATED.PUBLIC
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}?includeSubGroups=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
      })
      it('with includeParentGroup set should include parent group as well', async () => {
        const group = groups.PRE_CREATED.PUBLIC_CHILD
        const res = await chai.request(app)
          .get(`/groups/oldId/${group.oldId}?includeParentGroup=true`)
          .set('Authorization', `Bearer ${tokens.User.Admin}`)

        res.should.have.status(200)
      })
    })
  })

  describe('Failure in posting event should rollback group', () => {
    before(() => {
      helper.stubbedBus.callsFake(() => {
        throw new Error('Posting to Bus API Failed')
      })
    })
    after(() => {
      helper.stubbedBus.callsFake(() => {})
    })

    it('creation', async () => {
      const res = await chai.request(app)
        .post('/groups')
        .set('Authorization', `Bearer ${tokens.User.Admin}`)
        .send(groups.VALID)

      res.should.have.status(500)
      const allGroups = await helper.getAllGroups()
      const names = allGroups.map(g => g.name)
      names.should.not.include(groups.VALID.name)
    })
    it('updation', async () => {
      const group = groups.PRE_CREATED.PUBLIC
      const updatedGroup = _.omit({ ...group, domain: 'abcd.com' }, autoGeneratedGroupAttrs)

      const res = await chai.request(app)
        .put(`/groups/${group.id}`)
        .set('Authorization', `Bearer ${tokens.User.Admin}`)
        .send(_.omit(updatedGroup, 'oldId'))

      res.should.have.status(500)
      const entity = await helper.getGroup(group.id)
      entity.domain.should.be.eql(group.domain)
    })
    it('deletion', async () => {
      const res = await chai.request(app)
        .delete(`/groups/${groups.PRE_CREATED.PUBLIC.id}`)
        .set('Authorization', `Bearer ${tokens.User.Admin}`)

      res.should.have.status(500)
      helper.getGroup(groups.PRE_CREATED.PUBLIC.id).should.not.be.rejected
    })
  })
})
